

                             The Symbolic Compiler


This is a compiler pass which embeds symbolic execution into the program during
compilation. In essence, it inserts code that computes symbolic expressions for
each value in the program. The actual computation happens through calls to a
support library at run time.

To build the pass and the support library, make sure that LLVM 8 and Z3 are
installed and obtain the source code of compiler-rt from the LLVM project. Note
that it is not necessary to build compiler-rt. Then create a build directory
somewhere, and execute the following commands inside it:

$ cmake -G Ninja -DCOMPILER_RT_SOURCE=/path/to/compiler-rt /path/to/compiler/sources
$ ninja

If LLVM is installed in a non-standard location, add the CMake parameter
"-DLLVM_DIR=/path/to/llvm/cmake/module". The results of the build process are
libSymbolize.so, a pass that can be loaded into clang or opt, and
libSymRuntime.so, the support library that has to be linked with the target
programs.

To try the compiler, take some simple C code like the following:

#include <stdio.h>
#include <stdint.h>

int sym_make_symbolic(const char*, int, uint8_t);

int foo(int a, int b) {
    if (2 * a < b)
        return a;
    else if (a % b)
        return b;
    else
        return a + b;
}

int main(int argc, char* argv[]) {
    int x = sym_make_symbolic("x", 5, 32);
    printf("%d\n", foo(x, 7));
    return 0;
}

Save the code as "test.c". To compile it with symbolic execution built in, we
call "symcc", a wrapper around clang that loads our compiler pass and links the
program against the support library:

$ ./symcc test.c -o test
$ ./test

The program will execute the same computations as the uninstrumented version,
but additionally the injected code will track computations symbolically and
attempt to compute diverging inputs at each branch point. Note that, instead of
calling "sym_make_symbolic", you can also read from standard input; the data
will receive the same symbolic treatment.
