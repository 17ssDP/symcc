

                             The Symbolic Compiler


This is a compiler pass which embeds symbolic execution into the program during
compilation. In essence, it inserts code that computes symbolic expressions for
each value in the program. The actual computation happens through calls to a
support library at run time.

To build the pass and the support library, make sure that LLVM 8 and Z3 are
installed and obtain the source code of compiler-rt from the LLVM project. Note
that it is not necessary to build compiler-rt. Then create a build directory
somewhere, and execute the following commands inside it:

$ cmake -G Ninja -DCOMPILER_RT_SOURCE=/path/to/compiler-rt /path/to/compiler/sources
$ ninja

If LLVM is installed in a non-standard location, add the CMake parameter
"-DLLVM_DIR=/path/to/llvm/cmake/module". The results of the build process are
libSymbolize.so, a pass that can be loaded into clang or opt, and
libSymRuntime.so, the support library that has to be linked with the target
programs.

To try the compiler, take some simple C code like the following:

#include <stdio.h>
#include <stdint.h>

int _sym_build_variable(const char*, int, uint8_t);

int foo(int a, int b) {
    if (2 * a < b)
        return a;
    else if (a % b)
        return b;
    else
        return a + b;
}

int main(int argc, char* argv[]) {
    int x = _sym_build_variable("x", 5, 32);
    printf("%d\n", foo(x, 7));
    return 0;
}

Save the code as "test.c". To compile it with symbolic execution built in, we
need to load the compiler pass and link the object file against the symbolic
runtime:

$ clang -O3 -Xclang -load -Xclang ./libSymbolize.so -L. -lSymRuntime \
    test.c -o test
$ export LD_LIBRARY_PATH="$(pwd)"
$ ./test

The program will execute the same computations as the uninstrumented version,
but additionally the injected code will track computations symbolically and
attempt to compute diverging inputs at each branch point.
