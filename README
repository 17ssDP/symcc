

                             The Symbolic Compiler


This is a compiler pass which embeds symbolic execution into the program during
compilation. In essence, it inserts code that computes symbolic expressions for
each value in the program. The actual computation happens through calls to a
support library at run time.

To build the pass, make sure that LLVM 8 and Z3 are installed, create a build
directory somewhere, and execute the following commands inside the build
directory:

$ cmake -G Ninja /path/to/compiler/sources
$ ninja

If LLVM is installed in a non-standard location, add the CMake parameter
"-DLLVM_DIR=/path/to/llvm/cmake/module". The results of the build process are
libSymbolize.so, a pass that can be loaded into clang or opt, and
libSymRuntime.so, the support library that has to be linked with the target
programs.

To try the compiler, take some simple C code like the following:

#include <stdio.h>
#include <stdint.h>

int _sym_build_variable(const char*, int, uint8_t);

int foo(int a, int b) {
    if (2 * a < b)
        return a;
    else if (a % b)
        return b;
    else
        return a + b;
}

int main(int argc, char* argv[]) {
    int x = _sym_build_variable("x", 5, 32);
    printf("%d\n", foo(x, 7));
    return 0;
}

Save the code as "test.c". In addition to regular compilation, we need to load
the compiler pass and link the object file against the symbolic runtime:

$ clang -O3 -Xclang -load -Xclang ./libSymbolize.so -L. -lSymRuntime \
    test.c -o test
$ export LD_LIBRARY_PATH="$(pwd)"
$ ./test

The program will execute the same computations as the uninstrumented version,
but additionally the injected code will track computations symbolically and
attempt to compute diverging inputs at each branch point.
