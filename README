

                             The Symbolic Compiler


This is a compiler pass which embeds symbolic execution into the program during
compilation. In essence, it inserts code that computes symbolic expressions for
each value in the program. The actual computation happens through calls to a
support library at run time. For now, only the compiler pass is available, so
the resulting code will generate linker errors until the run-time library
becomes ready.

To build the pass, make sure that LLVM 8 is installed, create a build directory
somewhere, and execute the following commands inside the build directory:

$ cmake -G Ninja /path/to/compiler/sources
$ ninja

If LLVM is installed in a non-standard location, add the CMake parameter
"-DLLVM_DIR=/path/to/llvm/cmake/module". The result of the build process is
libSymbolize.so, which can be loaded into clang or opt.

To try the compiler, take a simple bitcode file like the following:

  ; ModuleID = 'simple.c'
  source_filename = "simple.c"
  target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
  target triple = "x86_64-pc-linux-gnu"

  ; Function Attrs: norecurse nounwind readnone sspstrong uwtable
  define dso_local i32 @foo(i32) local_unnamed_addr #0 {
    %2 = add nsw i32 %0, 1
    ret i32 %2
  }

  ; Function Attrs: norecurse nounwind readnone sspstrong uwtable
  define dso_local i32 @main(i32, i8** nocapture readnone) local_unnamed_addr #0 {
    ret i32 0
  }

  attributes #0 = { norecurse nounwind readnone sspstrong uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }

  !llvm.module.flags = !{!0, !1, !2}
  !llvm.ident = !{!3}

  !0 = !{i32 1, !"wchar_size", i32 4}
  !1 = !{i32 7, !"PIC Level", i32 2}
  !2 = !{i32 7, !"PIE Level", i32 2}
  !3 = !{!"clang version 8.0.0 (tags/RELEASE_800/final)"}

Save the file as "simple.ll" and run the following:

$ opt -load ./libSymbolize.so -symbolize < simple.ll | llvm-dis

The output should be the compilation logs, followed by a disassembly of the
transformed code.
