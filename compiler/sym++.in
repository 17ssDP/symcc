#!/bin/bash

runtime_64bit_dir="@SYM_RUNTIME_DIR@"
runtime_32bit_dir="@SYM_RUNTIME_32BIT_DIR@"
pass="@CMAKE_CURRENT_BINARY_DIR@/libSymbolize.so"

# Find out if we're cross-compiling for a 32-bit architecture
runtime_dir="$runtime_64bit_dir"
for arg in "$@"; do
    if [[ $arg == "-m32" ]]; then
        if [ -z "$runtime_32bit_dir" ]; then
            echo "SymCC: 32-bit compilation requested but SymCC was not built with TARGET_32BIT=ON" >&2
            exit 255
        else
            runtime_dir="$runtime_32bit_dir"
            break
        fi
    fi
done

if [[ -v SYMCC_REGULAR_LIBCXX ]]; then
    stdlib_cflags=
    stdlib_ldflags=
elif [[ ! -v SYMCC_LIBCXX_PATH ]]; then
    >&2 echo "Please set SYMCC_LIBCXX_PATH to the directory containing libc++ or confirm usage of the system library by setting SYMCC_REGULAR_LIBCXX!"
    exit 255
else
    # It is important that the resulting binaries load libstdc++ before libc++;
    # otherwise our backend calls the instrumented library in cases where
    # exported names collide.
    stdlib_cflags="-isystem $SYMCC_LIBCXX_PATH/include/c++/v1 -nostdlib++"
    stdlib_ldflags="-L$SYMCC_LIBCXX_PATH/lib -Wl,-rpath,$SYMCC_LIBCXX_PATH/lib -lstdc++ -lc++ -stdlib=libc++"
fi

exec @CLANGPP_BINARY@                           \
     -Xclang -load -Xclang "$pass"              \
     $stdlib_cflags                             \
     "$@"                                       \
     $stdlib_ldflags                            \
     -L"$runtime_dir"                           \
     -lSymRuntime                               \
     -Wl,-rpath,"$runtime_dir"                  \
     -Qunused-arguments
